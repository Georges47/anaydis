<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />



<title>Análisis y Diseño de Algoritmos</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.7/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.7/js/bootstrap.min.js"></script>
<link href="site_libs/magnific-popup-1.1.0/magnific-popup.css" rel="stylesheet" />
<script src="site_libs/magnific-popup-1.1.0/jquery.magnific-popup.min.js"></script>
<link href="site_libs/readthedown-0.1/readthedown.css" rel="stylesheet" />
<script src="site_libs/readthedown-0.1/readthedown.js"></script>



<link rel="stylesheet" href="styles.css" type="text/css" />

</head>

<body>


<div id="content" data-toggle="wy-nav-shift">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("text-table-of-contents");
});
</script>

<!-- code folding -->

<nav id="nav-top" role="navigation" aria-label="top navigation">
    <a role="button" href="#" data-toggle="wy-nav-top"><span class="glyphicon glyphicon-menu-hamburger"></span></a>
</nav>


<div id="header">
<h1 class="title">Análisis y Diseño de Algoritmos</h1>
</div>


<div id="sidebar">
    <h2><a href="#content">Análisis y Diseño de Algoritmos</a></h2>
    <div id="table-of-contents">
      <ul>
      <li><a href="#sorting">Sorting</a><ul>
      <li><a href="#algoritmos-elementales">Algoritmos elementales</a><ul>
      <li><a href="#selection-sort">Selection Sort</a></li>
      <li><a href="#insertion-sort">Insertion Sort</a></li>
      <li><a href="#bubble-sort">Bubble Sort</a></li>
      </ul></li>
      <li><a href="#análisis-de-algoritmos-elementales">Análisis de algoritmos elementales</a><ul>
      <li><a href="#tiempo-de-ejecución">Tiempo de ejecución</a><ul>
      <li><a href="#mejor-caso">Mejor caso</a></li>
      <li><a href="#peor-caso">Peor caso</a></li>
      <li><a href="#caso-promedio">Caso promedio</a></li>
      </ul></li>
      </ul></li>
      <li><a href="#shellsort">Shellsort</a><ul>
      <li><a href="#análisis-de-h">Análisis de h</a><ul>
      <li><a href="#section"></a></li>
      </ul></li>
      </ul></li>
      <li><a href="#quicksort">Quicksort</a><ul>
      <li><a href="#análisis-de-m">Análisis de M</a><ul>
      <li><a href="#section-1"></a></li>
      <li><a href="#section-6"></a></li>
      </ul></li>
      <li><a href="#análisis-de-variantes">Análisis de variantes</a><ul>
      <li><a href="#section-7"></a></li>
      <li><a href="#section-8"></a></li>
      </ul></li>
      </ul></li>
      <li><a href="#mergesort">Mergesort</a></li>
      </ul></li>
      <li><a href="#searching">Searching</a><ul>
      <li><a href="#análisis-de-maps">Análisis de Maps</a></li>
      </ul></li>
      </ul>
    </div>
    
    <div id="postamble" data-toggle="wy-nav-shift" class="status">
              <p class="author"><span class="glyphicon glyphicon-user"></span> Georges Stefan
                  </p>
                  <p class="date"><span class="glyphicon glyphicon-calendar"></span> 27 septiembre 2020</p>
        </div>
</div>

<div id="main">
<!-- <style> -->
<!-- body { -->
<!-- text-align: justify} -->
<!-- <!-- img { -->
<!-- <!--   cursor: pointer; -->
<!-- <!--   transition: -webkit-transform 0.1s ease -->
<!-- <!-- } -->
<!-- <!-- img:focus { -->
<!-- <!--   -webkit-transform: scale(2); -->
<!-- <!--   -ms-transform: scale(2); -->
<!-- <!--   z-index:1; -->
<!-- <!-- } -->
<!-- </style> -->
<!-- <!-- <script> -->
<!-- <!--     document.addEventListener('DOMContentLoaded', function(){ -->
<!-- <!--         var imgs = document.querySelectorAll('img'); -->
<!-- <!--         Array.prototype.forEach.call(imgs, function(el, i) { -->
<!-- <!--             if (el.tabIndex <= 0) el.tabIndex = 10000; -->
<!-- <!--         }); -->
<!-- <!--     }); -->
<!-- <!-- </script> -->
<div id="sorting" class="section level1">
<h1>Sorting</h1>
<!-- escribir algo sobre el sorting en si y luego podria hablar un poquito de time complexity -->
<p>Hay dos propiedades que vamos a considerar en estos algoritmos: estabilidad y adaptatividad.</p>
<p>Un algoritmo de sorting es estable si dos elementos iguales aparecen en el mismo orden en la salida ordenada tal como aparecen en la lista de entrada antes de que se va a ordenar, siendo no estable o inestable si este orden se modifica. <!-- Any comparison based sorting algorithm which is not stable by nature can be modified to be stable by changing the key comparison operation so that the comparison of two keys considers position as a factor for objects with equal key or by tweaking it in a way such that its meaning doesn’t change and it becomes stable as well. --></p>
<p>Un algoritmo de sorting es adaptativo si modifica su conducta (las operaciones que realiza) durante su ejecución, dependiendo del resultado de las comparaciones que hace. Mientras que es no adaptativo si la secuencia de operaciones que realiza es independiente del orden de los elementos.</p>
<div id="algoritmos-elementales" class="section level2">
<h2>Algoritmos elementales</h2>
<p>Los algoritmos elementales de sorting son tres:</p>
<ul>
<li>Selection Sort</li>
<li>Insertion Sort</li>
<li>Bubble Sort</li>
</ul>
<p>Los tres algoritmos son de tiempo cuadrático, tanto en el peor caso como en el promedio, y son in-place (no requieren memoria adicional). Aún así el funcionamiento de cada uno es distinto, como se verá a continuación.</p>
<div id="selection-sort" class="section level3">
<h3>Selection Sort</h3>
<p>El algoritmo recorre toda la lista para encontrar el elemento más pequeño, una vez que se encuentra se intercambia con el elemento en la primera posición. Luego se recorre la lista desde la segunda posición (ya que el elemento anterior está en su posición final) en búsqueda del segundo elemento más pequeño y una vez encontrado se intercambia con el elemento de la segunda posición. Se continua de este modo hasta que la lista esté ordenada.</p>
<p>Se llama “<strong>Selection</strong>” porque opera seleccionando repetidamente el elemento restante más pequeño. Es bueno cuando se deben realizar pocos intercambios.</p>
<p>Es <strong>inestable</strong>, ya que una vez que encuentra al elemento más pequeño de la parte desordenada, lo intercambia con el elemento que está en la posición correspondiente. Es <strong>no adaptativo</strong>, ya que realiza la misma cantidad de operaciones (y por lo tanto tarda el mismo tiempo) sin importar el orden de la lista inicial.</p>
<script language="javascript"> 
  function toggle(num) {
    var ele = document.getElementById("toggleText" + num);
    var text = document.getElementById("displayText" + num);
    if(ele.style.display == "block") {
      ele.style.display = "none";
      text.innerHTML = "show";
    }
    else {
      ele.style.display = "block";
      text.innerHTML = "hide";
    }
 } 
</script>
<a id="displayText" href="javascript:toggle(1);">Ejemplo de inestabilidad<br><br></a>
<div id="toggleText1" style="display: none">
<table style="width:100%">
<tr>
<td>
<p>Supongamos que tenemos la siguiente lista de enteros: 5 3 4 5 2 6</p>
<p>Ahora distingamos los números iguales de la siguiente manera: 5(a) 3 4 5(b) 2 6</p>
<p>Luego de la primera iteración el 2 se intercambiará con el elemento en la primera posición, por lo que la lista queda: 2 3 4 5(b) 5(a) 6</p>
<p>Ahora la lista está ordenada pero como se puede ver antes de utilizar el algoritmo 5(a) estaba antes de 5(b), mientras que ahora 5(a) está despues de 5(b). Por lo tanto, el algoritmo no es estable.</p>
</td>
</tr>
</table>
</div>
</div>
<div id="insertion-sort" class="section level3">
<h3>Insertion Sort</h3>
<p>El algoritmo considera un elemento a la vez, insertándolo en su lugar correspondiente entre aquellos elementos que han sido considerados previamente. Por lo tanto los elementos considerados van a estar ordenados pero no en sus posiciones finales, ya que puede que se tengan que mover al considerar un nuevo elemento.</p>
<p>Es <strong>estable</strong>, ya que intercambia elementos solo si son mayores, no si son iguales. Es <strong>adaptativo</strong>, ya que entre más ordenada esté la lista inicial, menor será su tiempo de ejecución.</p>
</div>
<div id="bubble-sort" class="section level3">
<h3>Bubble Sort</h3>
<p>El algoritmo itera sobre la lista, intercambiando elementos adyacentes que no estén en orden, continuando de esta manera hasta que la lista esté ordenada. Por lo tanto por cada iteración la lista se va ordenando cada vez más.</p>
<p>Es <strong>estable</strong>. ya que como el Insertion Sort, solo intercambia elementos si son mayores que el siguiente, no si son iguales. Es <strong>adaptativo</strong>, ya que entre más ordenada esté la lista inicial, menor será su tiempo de ejecución.</p>
</div>
</div>
<div id="análisis-de-algoritmos-elementales" class="section level2">
<h2>Análisis de algoritmos elementales</h2>
<p>Para este análisis hay tres posibles casos que vamos a considerar:</p>
<ul>
<li><strong>Mejor caso</strong>: Cuando la lista ya está ordenada, en nuestro caso consideramos una lista ordenada cuando está ordenada de manera ascendente.</li>
<li><strong>Peor caso</strong>: Cuando la lista está invertida, es decir, está ordenada de manera descendente.</li>
<li><strong>Caso promedio</strong>: Cuando los elementos de la lista están ordenados de manera random.</li>
</ul>
<!-- En el eje horizontal se utilizó una escala logarítmica de base 10, con el objetivo de “magnificar” la parte inferior de la curva (los valores de 10 y 50). -->
<div id="tiempo-de-ejecución" class="section level3 tabset unnumbered">
<h3>Tiempo de ejecución</h3>
<div id="mejor-caso" class="section level4 unnumbered unnumbered">
<h4>Mejor caso</h4>
<p><img src="./best_time.png" /></p>
<p>Teoricamente, en el mejor caso tanto Bubble Sort como Insertion Sort deberían tener un tiempo de ejecución lineal, mientras que el de Selection Sort sigue siendo cuadrático.</p>
<p>Ahora bien, empíricamente, podemos ver en la gráfica como Insertion Sort y Bubble Sort se asemejan a una recta, mientras que la curva del Selection Sort asciende con mayor rapidez, como era de esperarse.</p>
</div>
<div id="peor-caso" class="section level4 unnumbered unnumbered">
<h4>Peor caso</h4>
<p><img src="./worst_time.png" /></p>
<p>Teoricamente, en el peor caso Selection Sort hace siempre la misma cantidad de comparaciones e intercambios, sin importar el orden inicial de la lista, por lo que su tiempo de ejecución sigue siendo cuadrático. Mientras que a diferencia del mejor caso, ahora tanto Insertion Sort como Bubble Sort pasan a tener un tiempo de ejecución cuadrático.</p>
<p>En el gráfico podemos observar como Bubble Sort si parece expresar ese tiempo de ejecución cuadrático, aunque Selection Sort e Insertion Sort no, pareciendo más un tiempo lineal o muy levemente cuadrático.</p>
</div>
<div id="caso-promedio" class="section level4 unnumbered unnumbered">
<h4>Caso promedio</h4>
<p><img src="./average_time.png" /></p>
<p>Teoricamente, en el caso promedio los tres algoritmos también tienen un tiempo de ejecución cuadrático.</p>
<p>En la gráfica se puede observar como sucede lo mismo que en el peor caso: el Bubble Sort si expresa ese tiempo cuadrático, mientras que Selection Sort e Insertion sort, no tanto. La diferencia es que los tiempos son menores al peor caso.</p>
</div>
<!-- <br/> -->
<p>En el peor caso y en el promedio, el tiempo de los algoritmos de Insertion y Selection es similar, mientras que el tiempo de ejecución de Bubble se eleva mucho más a medida que aumenta n. Esta última observación era de esperarse. Wesley (2002) “Bubble sort generally will be slower than the other two methods…” (p. 262).</p>
<!-- ### Orden {.tabset .unnumbered} -->
<!-- #### Mejor caso {- .unnumbered} -->
<!-- . -->
<!-- #### Peor caso {- .unnumbered} -->
<!-- . -->
<!-- #### Caso promedio {- .unnumbered} -->
<!-- . -->
<!-- ### {.unnumbered} -->
<!-- <br/> -->
<p>En el caso de tener que desarrollar un programa que utilice alguno de los algoritmos elementales para ordenar una lista de objetos del tipo:</p>
<pre echo="FALSE"><code>public class FullName {
    private String firstname;
    private String lastname;
  
    public String getFirstname() {
        return firstname;
    }
  
    public String getLastname() {
        return lastname;
    }
}</code></pre>
<p>En el cual la lista debe ser ordenada dos veces, la primera por apellido y la segunda por nombre.</p>
<p>Yo implementé un FullNameComparator el cual tiene una lógica con la que se puede ordenar una lista de FullNames de esta manera deseada, sorteandola solo una vez. Por lo tanto, elegí utilizar Insertion Sort, ya que su tiempo de ejecución es de los menores entre los tres algoritmos, como podemos ver en las gráficas anteriores.</p>
</div>
</div>
</div>
<div id="shellsort" class="section level2">
<h2>Shellsort</h2>
<p>Una desventaja del algoritmo de Insertion sort es que solo puede intercambiar elementos adyacentes, por lo que los elementos solo pueden moverse una posición a la vez en la lista. Shellsort es una simple extensión de Insertion sort que permite intercambiar elementos no adyacentes, por lo que gana rapidez.</p>
<p>Una lista h-sorted es simplemente <span class="math inline">\(h\)</span> listas ordenadas intercaladas entre sí. Es decir, empezando en cualquier elemento y agregando el elemento que está <span class="math inline">\(h\)</span> posiciones por delante, siguiendo así hasta llegar al final de la lista, se tiene una sublista ordenada.</p>
<script language="javascript"> 
  function toggle(num) {
    var ele = document.getElementById("toggleText" + num);
    var text = document.getElementById("displayText" + num);
    if(ele.style.display == "block") {
      ele.style.display = "none";
      text.innerHTML = "show";
    }
    else {
      ele.style.display = "block";
      text.innerHTML = "hide";
    }
 } 
</script>
<a id="displayText" href="javascript:toggle(2);">Ejemplo de lista h-sorted<br><br></a>
<div id="toggleText2" style="display: none">
<table style="width:100%">
<tr>
<td>
<p>Por ejemplo, la siguiente lista está h-sorted con h = 3.</p>
<p><span class="math inline">\(479\hspace{0.45em} 1\hspace{0.45em} 26\hspace{0.45em} 752\hspace{0.45em} 4\hspace{0.45em} 56\hspace{0.45em} 981\hspace{0.45em} 7\hspace{0.45em} 83\)</span></p>
<p>Ya que empezando en cualquier elemento y avanzando con un delta de 3, tendremos una sublista ordenada. A continuación se muestran las 3 sublistas ordenadas, cada una destacada con un color :</p>
<p><span class="math inline">\(\color{red}{479\ }\)</span> <span class="math inline">\(\color{green}{1\ }\)</span> <span class="math inline">\(\color{blue}{26\ }\)</span> <span class="math inline">\(\color{red}{752\ }\)</span> <span class="math inline">\(\color{green}{4\ }\)</span> <span class="math inline">\(\color{blue}{56\ }\)</span> <span class="math inline">\(\color{red}{981\ }\)</span> <span class="math inline">\(\color{green}{7\ }\)</span> <span class="math inline">\(\color{blue}{83\ }\)</span></p>
</td>
</tr>
</table>
</div>
<p>La esencia del algoritmo de Shellsort es h-sortear varias veces la lista, utilizando una secuencia descendente de <span class="math inline">\(h\)</span> que finalice con <span class="math inline">\(h = 1\)</span>. El empezar con un <span class="math inline">\(h\)</span> grande permite intercambiar elementos que están lejos en la lista original, disminuyendo el desorden rápidamente y dejando menos trabajo que hacer para los <span class="math inline">\(h\)</span> más pequeños. Una vez que <span class="math inline">\(h = 1\)</span>, se estaría ejecutando un Insertion sort.</p>
<p>Es <strong>inestable</strong>, ya que no examina a los elementos que están entre los intervalos, por lo que puede cambiar el orden relativo de elementos iguales.</p>
<script language="javascript"> 
  function toggle(num) {
    var ele = document.getElementById("toggleText" + num);
    var text = document.getElementById("displayText" + num);
    if(ele.style.display == "block") {
      ele.style.display = "none";
      text.innerHTML = "show";
    }
    else {
      ele.style.display = "block";
      text.innerHTML = "hide";
    }
 } 
</script>
<a id="displayText" href="javascript:toggle(3);">Ejemplo de inestabilidad<br><br></a>
<div id="toggleText3" style="display: none">
<table style="width:100%">
<tr>
<td>
<p>Supongamos que tenemos la siguiente lista de enteros: <span class="math inline">\(5\ 5\ 3\ 1\ 2\ 7\)</span></p>
<p>Diferenciamos los elementos iguales: <span class="math inline">\(5(\text{a})\ 5(\text{b})\ 3\ 1\ 2\ 7\)</span></p>
<p>Ejecutamos Shellsort con la siguiente secuencia de <span class="math inline">\(h\)</span>: {2, 1}</p>
<p>Luego h-sortear con <span class="math inline">\(h = 2\)</span>, la lista queda: <span class="math inline">\(\ \color{red}{2\ }\)</span> <span class="math inline">\(\color{blue}{1\ }\)</span> <span class="math inline">\(\color{red}{3\ }\)</span> <span class="math inline">\(\color{blue}{5(\text{b})\ }\)</span> <span class="math inline">\(\color{red}{5(\text{a})\ }\)</span> <span class="math inline">\(\color{blue}{7\ }\)</span></p>
<p>Luego de h-sortear con <span class="math inline">\(h = 1\)</span>, la lista ya está ordenada y queda: <span class="math inline">\(1\ 2\ 3\ 5(\text{b})\ 5(\text{a})\ 7\)</span></p>
<p>Ahora la lista está ordenada pero como podemos ver, antes de utilizar el algoritmo, 5(a) estaba antes de 5(b), mientras que ahora 5(a) está despues de 5(b). Por lo tanto, el algoritmo no es estable.</p>
</td>
</tr>
</table>
</div>
<p>Es <strong>in-place</strong>, ya que no requiere memoria adicional y es <strong>adaptativo</strong>, ya que se ejecuta más rápidamente si la lista inicial está parcialmente ordenada… (quizas poner un ejemplo).</p>
<div id="análisis-de-h" class="section level3">
<h3>Análisis de h</h3>
<p>A continuación se compara el rendimiento de Shellsort con distintas secuencias de h, estas son:</p>
<ul>
<li>Primera secuencia: <span class="math inline">\(1,\ 8,\ 23,\ 77,\ 281,\ 1073,\ 4193,\ 16577,\ \dots\)</span></li>
<li>Segunda secuencia: <span class="math inline">\(1,\ 4,\ 13,\ 40,\ 121,\ 364,\ 1093,\ 3280,\ 9841,\ \dots\)</span></li>
</ul>
<div id="section" class="section level4 tabset unnumbered">
<h4></h4>
<div id="tiempo-de-ejecución-1" class="section level5 unnumbered unnumbered">
<h5>Tiempo de ejecución</h5>
<div class = "row">
<div class="col-md-8">
<p><img src="index_files/figure-html/unnamed-chunk-2-1.png" width="768" /> <!-- ![](./shellsort_times.png) --></p>
</div>
<div class = "col-md-3.5">
<center>
<h3>
Tiempos              
</h3>
</center>
<table style='width:30%;'>
<thead>
<tr>
<th style="text-align:right;">
n
</th>
<th style="text-align:right;">
Primera secuencia
</th>
<th style="text-align:right;">
Segunda secuencia
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right;">
100
</td>
<td style="text-align:right;">
3
</td>
<td style="text-align:right;">
1
</td>
</tr>
<tr>
<td style="text-align:right;">
1000
</td>
<td style="text-align:right;">
12
</td>
<td style="text-align:right;">
8
</td>
</tr>
<tr>
<td style="text-align:right;">
2500
</td>
<td style="text-align:right;">
34
</td>
<td style="text-align:right;">
31
</td>
</tr>
<tr>
<td style="text-align:right;">
5000
</td>
<td style="text-align:right;">
122
</td>
<td style="text-align:right;">
122
</td>
</tr>
<tr>
<td style="text-align:right;">
10000
</td>
<td style="text-align:right;">
492
</td>
<td style="text-align:right;">
491
</td>
</tr>
<tr>
<td style="text-align:right;">
15000
</td>
<td style="text-align:right;">
1106
</td>
<td style="text-align:right;">
1179
</td>
</tr>
<tr>
<td style="text-align:right;">
20000
</td>
<td style="text-align:right;">
1967
</td>
<td style="text-align:right;">
2143
</td>
</tr>
</tbody>
</table>
</div>
</div>
<p>Como se puede apreciar tanto en la gráfica como en la tabla de valores, ambos tiempos son similares para valores menores que 10000 elementos. A medida que aumenta n, da la impresión de que la segunda secuencia consume más tiempo que la primera.</p>
</div>
<div id="cantidad-de-comparaciones" class="section level5 unnumbered unnumbered">
<h5>Cantidad de comparaciones</h5>
<div class = "row">
<div class="col-md-8">
<p><img src="index_files/figure-html/unnamed-chunk-4-1.png" width="768" /> <!-- ![](./shellsort_comparisons.png) --></p>
</div>
<div class = "col-md-3.5">
<center>
<h3>
Comparaciones        
</h3>
</center>
<table>
<thead>
<tr>
<th style="text-align:right;">
n
</th>
<th style="text-align:right;">
Primera secuencia
</th>
<th style="text-align:right;">
Segunda secuencia
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right;">
100
</td>
<td style="text-align:right;">
2759
</td>
<td style="text-align:right;">
2813
</td>
</tr>
<tr>
<td style="text-align:right;">
1000
</td>
<td style="text-align:right;">
255864
</td>
<td style="text-align:right;">
253877
</td>
</tr>
<tr>
<td style="text-align:right;">
2500
</td>
<td style="text-align:right;">
1567448
</td>
<td style="text-align:right;">
1569861
</td>
</tr>
<tr>
<td style="text-align:right;">
5000
</td>
<td style="text-align:right;">
6264013
</td>
<td style="text-align:right;">
6288922
</td>
</tr>
<tr>
<td style="text-align:right;">
10000
</td>
<td style="text-align:right;">
25046097
</td>
<td style="text-align:right;">
25069860
</td>
</tr>
<tr>
<td style="text-align:right;">
15000
</td>
<td style="text-align:right;">
56411250
</td>
<td style="text-align:right;">
56394983
</td>
</tr>
<tr>
<td style="text-align:right;">
20000
</td>
<td style="text-align:right;">
100020867
</td>
<td style="text-align:right;">
100120437
</td>
</tr>
</tbody>
</table>
</div>
</div>
<p>En cuanto a la cantidad de comparaciones, en la gráfica no se aprecia tanto, pero en la tabla de valores se puede ver como en la mayoría de los casos la segunda secuencia realiza más comparaciones<!-- , aunque la diferencia es prácticamente despreciable-->.</p>
</div>
</div>
</div>
</div>
</div>
<div id="quicksort" class="section level2">
<h2>Quicksort</h2>
<p>La idea de este algoritmo consiste en elegir un elemento de la lista (denominado pivote) a partir del cual se particiona en dos. Una vez escogido el pivote se reordena la lista de modo que se cumplan las siguientes condiciones:</p>
<ul>
<li>El pivote está en su posición final.</li>
<li>Todos los elementos posicionados antes del pivote son menores que él.</li>
<li>Todos los elementos posicionados luego del pivote son mayores que él.</li>
</ul>
<p>Luego de particionar la lista de esta manera, se realizan los mismos pasos en cada una de las particiones, es decir, se sigue recursivamente.</p>
<p>Es <strong>inestable</strong>, ya que en el proceso de partición una clave puede ser movida cruzando a otras iguales.</p>
<script language="javascript"> 
  function toggle(num) {
    var ele = document.getElementById("toggleText" + num);
    var text = document.getElementById("displayText" + num);
    if(ele.style.display == "block") {
      ele.style.display = "none";
      text.innerHTML = "show";
    }
    else {
      ele.style.display = "block";
      text.innerHTML = "hide";
    }
 } 
</script>
<a id="displayText" href="javascript:toggle(4);">Ejemplo de inestabilidad<br><br></a>
<div id="toggleText4" style="display: none">
<table style="width:100%">
<tr>
<td>
<p>Supongamos que tenemos la siguiente lista de enteros: <span class="math inline">\(4\ 1\ 2\ 4\ 3\)</span></p>
<p>Diferenciando los elementos iguales: <span class="math inline">\(4(\text{a})\ 1\ 2\ 4(\text{b})\ 3\)</span></p>
<p>Se toma como pivote (en azul) el último elemento: <span class="math inline">\(4(\text{a})\ 1\ 2\ 4(\text{b})\ \color{blue}{3}\)</span></p>
<p>Luego un puntero busca desde la izquierda un elemento mayor que el pivote y otro puntero busca desde la derecha un elemento menor que el pivote.</p>
<p>Marcando en rojo estos elementos una vez encontrados tenemos: <span class="math inline">\(\color{red}{4(\text{a})}\ 1\ \color{red}{2}\ 4(\text{b})\ \color{blue}{3}\)</span></p>
<p>Intercambiando estos elementos entre sí: <span class="math inline">\(\color{red}{2}\ 1\ \color{red}{4(\text{a})}\ 4(\text{b})\ \color{blue}{3}\)</span></p>
<p>Una vez que se encuentran ambos punteros (en <span class="math inline">\(1\)</span>) se ubica al pivote: <span class="math inline">\(2\ 1\ \color{blue}{3}\ 4(\text{b})\ 4(\text{a})\)</span></p>
<p>Terminando de ordenar la lista: <span class="math inline">\(1\ 2\ 3\ 4(\text{b})\ 4(\text{a})\)</span></p>
<p>Ahora la lista está ordenada pero como podemos ver, antes de utilizar el algoritmo, 4(a) estaba antes de 4(b), mientras que ahora 4(a) está despues de 4(b). Por lo tanto, el algoritmo no es estable.</p>
</td>
</tr>
</table>
</div>
<!-- Es **in-place**, pero no se si es **adaptativo**. -->
<p>Visualmente el proceso de particionamiento para una lista ordenada al azar sería el siguiente:</p>
<p><img src="quicksort_partitioning.jpg" /></p>
<p>A lo largo del proceso podemos ver como se van intercambiando los elementos que están a la izquierda y son mayores que el pivote, con los elementos que están a la derecha y son menores que el pivote.</p>
<p>En la última escena, una vez que finaliza el proceso, se puede observar como todos los elementos a la izquierda del pivote son menores que él, y por eso no hay ningún elemento que esté a su izquierda y por encima suyo. De igual manera todos los elementos a la derecha del pivote son mayores que él, así que no hay ningún elemento que esté a su derecha y por debajo suyo.</p>
<div id="análisis-de-m" class="section level3">
<h3>Análisis de M</h3>
<p>Una posible mejora de este algoritmo es hacer que cuando el número de elementos está por debajo de alguna cota (denominada M), se cambie a un algoritmo de sorting no recursivo como Insertion Sort. La razón de elegir Insertion sort se debe a que es el mejor algoritmo no recursivo para ordenar archivos que están parcialmente ordenados.</p>
<p>Wesley (2002, p. 302) señala que la elección del valor óptimo para M da como resultado una mejora de aproximadamente un 10% en el tiempo promedio de ejecución.</p>
<p>A continuación se muestran los resultados de un análisis empírico sobre el valor de M con respecto al tiempo de ejecución. Los análisis se realizaron para N = 1.000, 10.000, 100.000, 1.000.000 y se muestra en color rojo los valores de M para los que el tiempo de ejecución fue menor.</p>
<div id="centerAlign">

</div>
<div id="section-1" class="section level4 tabset unnumbered">
<h4></h4>
<div id="section-2" class="section level5 unnumbered unnumbered">
<h5>1.000</h5>
<div id="centerAlign">
<p><img src="index_files/figure-html/unnamed-chunk-7-1.png" width="768" /></p>
</div>
<p>Para N = 1.000, el menor valor es de 0 ms y se consigue con M = 6, 8, 9, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20.</p>
</div>
<div id="section-3" class="section level5 unnumbered unnumbered">
<h5>10.000</h5>
<div id="centerAlign">
<p><img src="index_files/figure-html/unnamed-chunk-8-1.png" width="768" /></p>
</div>
<p>Para N = 10.000, el menor valor es de 6 ms y se consigue con M = 10, 12, 13, 14, 17, 18, 20.</p>
</div>
<div id="section-4" class="section level5 unnumbered unnumbered">
<h5>100.000</h5>
<div id="centerAlign">
<p><img src="index_files/figure-html/unnamed-chunk-9-1.png" width="768" /></p>
</div>
<p>Para N = 100.000, el menor valor es de 64 ms y se consigue con M = 10.</p>
</div>
<div id="section-5" class="section level5 unnumbered unnumbered">
<h5>1.000.000</h5>
<div id="centerAlign">
<p><img src="index_files/figure-html/unnamed-chunk-10-1.png" width="768" /></p>
</div>
<p>Para N = 1.000.000, el menor valor es de 1024 ms y se consigue con M = 7.</p>
</div>
</div>
<div id="section-6" class="section level4 unnumbered">
<h4></h4>
<!-- Entre 10.000 y 100.000 el mejor valor es M=10 -->
</div>
</div>
<div id="análisis-de-variantes" class="section level3">
<h3>Análisis de variantes</h3>
<p>A continuación se exponen los resultados de un análisis de rendimiento realizado a las siguientes cinco variantes de Quicksort:</p>
<ul>
<li>Estándar</li>
<li>No recursivo</li>
<li>Híbrido</li>
<li>Mediana de tres</li>
<li>Partición de tres vías (Three-way partitioning)</li>
</ul>
<p>Como se utilizaron listas de enteros ordenados al azar para el análisis, con N = 12.500, 25.000, 50.000, 100.000, se utiliza M = 10 ya que de la sección anterior (Análisis de M) podemos observar que este es el valor óptimo para valores de N entre 10.000 y 100.000.</p>
<div id="section-7" class="section level4 tabset unnumbered">
<h4></h4>
<div id="tiempo-de-ejecución-2" class="section level5 unnumbered unnumbered">
<h5>Tiempo de ejecución</h5>
<div id="centerAlign">
<img src="index_files/figure-html/unnamed-chunk-12-1.png" width="768" />
<h3>
Tiempos        
</h3>
</div>
<table class="centerAlign">
<thead>
<tr>
<th style="text-align:right;">
N
</th>
<th style="text-align:right;">
Estándar
</th>
<th style="text-align:right;">
No recursivo
</th>
<th style="text-align:right;">
Híbrido
</th>
<th style="text-align:right;">
Mediana de tres
</th>
<th style="text-align:right;">
Partición de tres vías
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right;">
12.500
</td>
<td style="text-align:right;">
4
</td>
<td style="text-align:right;">
6
</td>
<td style="text-align:right;">
5
</td>
<td style="text-align:right;">
7
</td>
<td style="text-align:right;">
12
</td>
</tr>
<tr>
<td style="text-align:right;">
25.000
</td>
<td style="text-align:right;">
13
</td>
<td style="text-align:right;">
14
</td>
<td style="text-align:right;">
12
</td>
<td style="text-align:right;">
15
</td>
<td style="text-align:right;">
29
</td>
</tr>
<tr>
<td style="text-align:right;">
50.000
</td>
<td style="text-align:right;">
35
</td>
<td style="text-align:right;">
39
</td>
<td style="text-align:right;">
28
</td>
<td style="text-align:right;">
35
</td>
<td style="text-align:right;">
63
</td>
</tr>
<tr>
<td style="text-align:right;">
100.000
</td>
<td style="text-align:right;">
69
</td>
<td style="text-align:right;">
71
</td>
<td style="text-align:right;">
69
</td>
<td style="text-align:right;">
71
</td>
<td style="text-align:right;">
147
</td>
</tr>
</tbody>
</table>
</div>
<div id="cantidad-de-comparaciones-1" class="section level5 unnumbered unnumbered">
<h5>Cantidad de comparaciones</h5>
<div id="centerAlign">
<img src="index_files/figure-html/unnamed-chunk-14-1.png" width="768" />
<h3>
Comparaciones        
</h3>
</div>
<table class="centerAlign">
<thead>
<tr>
<th style="text-align:right;">
N
</th>
<th style="text-align:right;">
Estándar
</th>
<th style="text-align:right;">
No recursivo
</th>
<th style="text-align:right;">
Híbrido
</th>
<th style="text-align:right;">
Mediana de tres
</th>
<th style="text-align:right;">
Partición de tres vías
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right;">
12.500
</td>
<td style="text-align:right;">
214.408
</td>
<td style="text-align:right;">
209.794
</td>
<td style="text-align:right;">
184.584
</td>
<td style="text-align:right;">
196.338
</td>
<td style="text-align:right;">
350.466
</td>
</tr>
<tr>
<td style="text-align:right;">
25.000
</td>
<td style="text-align:right;">
448.883
</td>
<td style="text-align:right;">
455.625
</td>
<td style="text-align:right;">
395.745
</td>
<td style="text-align:right;">
447.418
</td>
<td style="text-align:right;">
772.353
</td>
</tr>
<tr>
<td style="text-align:right;">
50.000
</td>
<td style="text-align:right;">
974.670
</td>
<td style="text-align:right;">
977.303
</td>
<td style="text-align:right;">
866.630
</td>
<td style="text-align:right;">
961.694
</td>
<td style="text-align:right;">
1.609.978
</td>
</tr>
<tr>
<td style="text-align:right;">
100.000
</td>
<td style="text-align:right;">
2.073.437
</td>
<td style="text-align:right;">
2.101.669
</td>
<td style="text-align:right;">
1.873.890
</td>
<td style="text-align:right;">
2.115.682
</td>
<td style="text-align:right;">
3.569.284
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="section-8" class="section level4 unnumbered">
<h4></h4>
</div>
</div>
</div>
<div id="mergesort" class="section level2">
<h2>Mergesort</h2>
<p>Es un algoritmo <strong>estable</strong>, de tipo “divide and conquer” y de complejidad O(n log n) garantizada.</p>
<p>Conceptualmente funciona de la siguiente manera:</p>
<ol style="list-style-type: decimal">
<li>Divide la lista inicial (desordenada) en n sublistas, cada una con un solo elemento. Cada una de estas n listas estará ordenada, ya que una lista con un único elemento se considera ordenada.</li>
<li>Se procede a <em>mergear</em> las sublistas para obtener nuevas sublistas ordenadas, hasta que quede una única sublista, la cual será la lista ordenada.</li>
</ol>
<p>Mergear no es más que el proceso de combinar dos archivos <em>ordenados</em> para obtener un único archivo ordenado.</p>
<!-- **in place? adaptativo?** -->
<p>Hay dos posibles implementaciones de Mergesort:</p>
<ul>
<li><strong>Top Down:</strong> Utiliza recursión. Divide la lista en dos partes, las ordena independientemente (mediante llamdas recursivas) y luego mergea las sublistas ordenadas para producir la lista ordenada final.</li>
<li><strong>Bottom Up:</strong> No utiliza recursión. Itera sobre la lista desordenada, mergeando sublistas de m por m duplicando m por cada iteración, hasta que m = N/2.</li>
</ul>
<p>A continuación se presentan los resultados de un análisis comparativo entre ambas implementaciones, tabulando el tiempo de ejecución (en milisegundos) utilizado para ordenar listas de N enteros random para N = 100, 500, 1.000, 2.500, 5.000.</p>
<div class = "row">
<div class="col-md-8">
<p><img src="index_files/figure-html/unnamed-chunk-17-1.png" width="768" /></p>
</div>
<div class = "col-md-3.5">
<center>
<h3>
Tiempos        
</h3>
</center>
<table>
<thead>
<tr>
<th style="text-align:right;">
N
</th>
<th style="text-align:right;">
Top Down
</th>
<th style="text-align:right;">
Bottom Up
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right;">
100
</td>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
1
</td>
</tr>
<tr>
<td style="text-align:right;">
500
</td>
<td style="text-align:right;">
7
</td>
<td style="text-align:right;">
7
</td>
</tr>
<tr>
<td style="text-align:right;">
1.000
</td>
<td style="text-align:right;">
8
</td>
<td style="text-align:right;">
9
</td>
</tr>
<tr>
<td style="text-align:right;">
2.500
</td>
<td style="text-align:right;">
13
</td>
<td style="text-align:right;">
36
</td>
</tr>
<tr>
<td style="text-align:right;">
5.000
</td>
<td style="text-align:right;">
53
</td>
<td style="text-align:right;">
151
</td>
</tr>
</tbody>
</table>
</div>
<p><br/><br/><br/><br/><br/><br/></p>
<p>Se puede observar como a medida que incrementa la cantidad de elementos (n), la implementación bottom-up utiliza más tiempo que la implementación bottom-up. Esto coincide con lo esperado: Wesley (2002, p. 332) indica que para listas de enteros random, la implementación top-down es 10% más rápida que la bottom-up.</p>
</div>
</div>
<div id="searching" class="section level1">
<h1>Searching</h1>
<div id="análisis-de-maps" class="section level2">
<h2>Análisis de Maps</h2>
<p>Un Map es una estructura de datos que almacena pares ‘clave:valor’, de tal manera que para una clave solamente tenemos un valor.</p>
<p>A continuación se muestran los resultados de un análisis de rendimiento realizado a dos implementaciones de Map (ArrayMap y RandomizedTreeMap), en el peor caso.</p>
<p>Para el análisis se realizó N búsquedas de palabras, midiendo el tiempo total que cada implementación utiliza. Cada resultado es un promedio de 10 cálculos.</p>
<p><img src="index_files/figure-html/unnamed-chunk-19-1.png" width="768" /></p>
<p>Se puede observar como la implementación RandomizedTreeMap es más eficiente, ya que utiliza menos tiempo que la implementación ArrayMap. <!-- , como era de esperarse. --></p>
<!-- El orden de búsqueda de ArrayMap es de $O(\log_2N)$ -->
</div>
</div>
</div>


</div>




<script>
$(document).ready(function () {
 	  });
</script>


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
